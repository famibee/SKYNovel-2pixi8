{"version":3,"file":"EventBoundary.js","sources":["../node_modules/pixi.js/lib/events/FederatedEvent.mjs","../node_modules/pixi.js/lib/events/EventTicker.mjs","../node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs","../node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs","../node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs","../node_modules/pixi.js/lib/events/EventBoundary.mjs"],"sourcesContent":["import { Point } from '../maths/point/Point.mjs';\n\n\"use strict\";\nclass FederatedEvent {\n  /**\n   * @param manager - The event boundary which manages this event. Propagation can only occur\n   *  within the boundary's jurisdiction.\n   */\n  constructor(manager) {\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    this.bubbles = true;\n    /** @deprecated since 7.0.0 */\n    this.cancelBubble = true;\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    this.cancelable = false;\n    /**\n     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    this.composed = false;\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    this.defaultPrevented = false;\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    this.eventPhase = FederatedEvent.prototype.NONE;\n    /** Flags whether propagation was stopped. */\n    this.propagationStopped = false;\n    /** Flags whether propagation was immediately stopped. */\n    this.propagationImmediatelyStopped = false;\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    this.layer = new Point();\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    this.page = new Point();\n    this.NONE = 0;\n    this.CAPTURING_PHASE = 1;\n    this.AT_TARGET = 2;\n    this.BUBBLING_PHASE = 3;\n    this.manager = manager;\n  }\n  /** @readonly */\n  get layerX() {\n    return this.layer.x;\n  }\n  /** @readonly */\n  get layerY() {\n    return this.layer.y;\n  }\n  /** @readonly */\n  get pageX() {\n    return this.page.x;\n  }\n  /** @readonly */\n  get pageY() {\n    return this.page.y;\n  }\n  /**\n   * Fallback for the deprecated @code{InteractionEvent.data}.\n   * @deprecated since 7.0.0\n   */\n  get data() {\n    return this;\n  }\n  /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */\n  composedPath() {\n    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {\n      this.path = this.target ? this.manager.propagationPath(this.target) : [];\n    }\n    return this.path;\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.\n   * @deprecated\n   * @param _type\n   * @param _bubbles\n   * @param _cancelable\n   */\n  initEvent(_type, _bubbles, _cancelable) {\n    throw new Error(\"initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.\");\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.\n   * @deprecated\n   * @param _typeArg\n   * @param _bubblesArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   */\n  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n    throw new Error(\"initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.\");\n  }\n  /** Prevent default behavior of PixiJS and the user agent. */\n  preventDefault() {\n    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {\n      this.nativeEvent.preventDefault();\n    }\n    this.defaultPrevented = true;\n  }\n  /**\n   * Stop this event from propagating to any addition listeners, including on the\n   * {@link FederatedEventTarget.currentTarget currentTarget} and also the following\n   * event targets on the propagation path.\n   */\n  stopImmediatePropagation() {\n    this.propagationImmediatelyStopped = true;\n  }\n  /**\n   * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners\n   * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\nexport { FederatedEvent };\n//# sourceMappingURL=FederatedEvent.mjs.map\n","import { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\n\"use strict\";\nclass EventsTickerClass {\n  constructor() {\n    /** The frequency that fake events will be fired. */\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /**\n   * Initializes the event ticker.\n   * @param events - The event system.\n   */\n  init(events) {\n    this.removeTickerListener();\n    this.events = events;\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /** Whether to pause the update checks or not. */\n  get pauseUpdate() {\n    return this._pauseUpdate;\n  }\n  set pauseUpdate(paused) {\n    this._pauseUpdate = paused;\n  }\n  /** Adds the ticker listener. */\n  addTickerListener() {\n    if (this._tickerAdded || !this.domElement) {\n      return;\n    }\n    Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n    this._tickerAdded = true;\n  }\n  /** Removes the ticker listener. */\n  removeTickerListener() {\n    if (!this._tickerAdded) {\n      return;\n    }\n    Ticker.system.remove(this._tickerUpdate, this);\n    this._tickerAdded = false;\n  }\n  /** Sets flag to not fire extra events when the user has already moved there mouse */\n  pointerMoved() {\n    this._didMove = true;\n  }\n  /** Updates the state of interactive objects. */\n  _update() {\n    if (!this.domElement || this._pauseUpdate) {\n      return;\n    }\n    if (this._didMove) {\n      this._didMove = false;\n      return;\n    }\n    const rootPointerEvent = this.events[\"_rootPointerEvent\"];\n    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === \"touch\") {\n      return;\n    }\n    globalThis.document.dispatchEvent(new PointerEvent(\"pointermove\", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY,\n      pointerType: rootPointerEvent.pointerType,\n      pointerId: rootPointerEvent.pointerId\n    }));\n  }\n  /**\n   * Updates the state of interactive objects if at least {@link interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link Ticker.system}.\n   * @param ticker - The throttled ticker.\n   */\n  _tickerUpdate(ticker) {\n    this._deltaTime += ticker.deltaTime;\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n    this._deltaTime = 0;\n    this._update();\n  }\n}\nconst EventsTicker = new EventsTickerClass();\n\nexport { EventsTicker };\n//# sourceMappingURL=EventTicker.mjs.map\n","import { Point } from '../maths/point/Point.mjs';\nimport { FederatedEvent } from './FederatedEvent.mjs';\n\n\"use strict\";\nclass FederatedMouseEvent extends FederatedEvent {\n  constructor() {\n    super(...arguments);\n    /** The coordinates of the mouse event relative to the canvas. */\n    this.client = new Point();\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    this.movement = new Point();\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    this.offset = new Point();\n    /** The pointer coordinates in world space. */\n    this.global = new Point();\n    /**\n     * The pointer coordinates in the renderer's {@link Renderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    this.screen = new Point();\n  }\n  /** @readonly */\n  get clientX() {\n    return this.client.x;\n  }\n  /** @readonly */\n  get clientY() {\n    return this.client.y;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n   * @readonly\n   */\n  get x() {\n    return this.clientX;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n   * @readonly\n   */\n  get y() {\n    return this.clientY;\n  }\n  /** @readonly */\n  get movementX() {\n    return this.movement.x;\n  }\n  /** @readonly */\n  get movementY() {\n    return this.movement.y;\n  }\n  /** @readonly */\n  get offsetX() {\n    return this.offset.x;\n  }\n  /** @readonly */\n  get offsetY() {\n    return this.offset.y;\n  }\n  /** @readonly */\n  get globalX() {\n    return this.global.x;\n  }\n  /** @readonly */\n  get globalY() {\n    return this.global.y;\n  }\n  /**\n   * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.\n   * @readonly\n   */\n  get screenX() {\n    return this.screen.x;\n  }\n  /**\n   * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.\n   * @readonly\n   */\n  get screenY() {\n    return this.screen.y;\n  }\n  /**\n   * This will return the local coordinates of the specified container for this InteractionData\n   * @param {Container} container - The Container that you would like the local\n   *  coords off\n   * @param {PointData} point - A Point object in which to store the value, optional (otherwise\n   *  will create a new point)\n   * @param {PointData} globalPos - A Point object containing your custom global coords, optional\n   *  (otherwise will use the current global coords)\n   * @returns - A point containing the coordinates of the InteractionData position relative\n   *  to the Container\n   */\n  getLocalPosition(container, point, globalPos) {\n    return container.worldTransform.applyInverse(globalPos || this.global, point);\n  }\n  /**\n   * Whether the modifier key was pressed when this event natively occurred.\n   * @param key - The modifier key.\n   */\n  getModifierState(key) {\n    return \"getModifierState\" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n  }\n  /**\n   * Not supported.\n   * @param _typeArg\n   * @param _canBubbleArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   * @param _screenXArg\n   * @param _screenYArg\n   * @param _clientXArg\n   * @param _clientYArg\n   * @param _ctrlKeyArg\n   * @param _altKeyArg\n   * @param _shiftKeyArg\n   * @param _metaKeyArg\n   * @param _buttonArg\n   * @param _relatedTargetArg\n   * @deprecated since 7.0.0\n   */\n  // eslint-disable-next-line max-params\n  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n\nexport { FederatedMouseEvent };\n//# sourceMappingURL=FederatedMouseEvent.mjs.map\n","import { FederatedMouseEvent } from './FederatedMouseEvent.mjs';\n\n\"use strict\";\nclass FederatedPointerEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    this.width = 0;\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    this.height = 0;\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    this.isPrimary = false;\n  }\n  // Only included for completeness for now\n  getCoalescedEvents() {\n    if (this.type === \"pointermove\" || this.type === \"mousemove\" || this.type === \"touchmove\") {\n      return [this];\n    }\n    return [];\n  }\n  // Only included for completeness for now\n  getPredictedEvents() {\n    throw new Error(\"getPredictedEvents is not supported!\");\n  }\n}\n\nexport { FederatedPointerEvent };\n//# sourceMappingURL=FederatedPointerEvent.mjs.map\n","import { FederatedMouseEvent } from './FederatedMouseEvent.mjs';\n\n\"use strict\";\nclass FederatedWheelEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /** Units specified in pixels. */\n    this.DOM_DELTA_PIXEL = 0;\n    /** Units specified in lines. */\n    this.DOM_DELTA_LINE = 1;\n    /** Units specified in pages. */\n    this.DOM_DELTA_PAGE = 2;\n  }\n}\n/** Units specified in pixels. */\nFederatedWheelEvent.DOM_DELTA_PIXEL = 0;\n/** Units specified in lines. */\nFederatedWheelEvent.DOM_DELTA_LINE = 1;\n/** Units specified in pages. */\nFederatedWheelEvent.DOM_DELTA_PAGE = 2;\n\nexport { FederatedWheelEvent };\n//# sourceMappingURL=FederatedWheelEvent.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\nimport { EventsTicker } from './EventTicker.mjs';\nimport { FederatedMouseEvent } from './FederatedMouseEvent.mjs';\nimport { FederatedPointerEvent } from './FederatedPointerEvent.mjs';\nimport { FederatedWheelEvent } from './FederatedWheelEvent.mjs';\n\n\"use strict\";\nconst PROPAGATION_LIMIT = 2048;\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    this.dispatch = new EventEmitter();\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    this.moveOnAll = false;\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    this.enableGlobalMoveEvents = true;\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    this.mappingState = {\n      trackingData: {}\n    };\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    this.eventPool = /* @__PURE__ */ new Map();\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    this._allInteractiveElements = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    this._hitElements = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    this._isPointerMoveEvent = false;\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping(\"pointerdown\", this.mapPointerDown);\n    this.addEventMapping(\"pointermove\", this.mapPointerMove);\n    this.addEventMapping(\"pointerout\", this.mapPointerOut);\n    this.addEventMapping(\"pointerleave\", this.mapPointerOut);\n    this.addEventMapping(\"pointerover\", this.mapPointerOver);\n    this.addEventMapping(\"pointerup\", this.mapPointerUp);\n    this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside);\n    this.addEventMapping(\"wheel\", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    if (!this.mappingTable[type]) {\n      this.mappingTable[type] = [];\n    }\n    this.mappingTable[type].push({\n      fn,\n      priority: 0\n    });\n    this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e - The event to dispatch.\n   * @param type - The type of event to dispatch. Defaults to `e.type`.\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = false;\n    e.propagationImmediatelyStopped = false;\n    this.propagate(e, type);\n    this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e - The event to map.\n   */\n  mapEvent(e) {\n    if (!this.rootTarget) {\n      return;\n    }\n    const mappers = this.mappingTable[e.type];\n    if (mappers) {\n      for (let i = 0, j = mappers.length; i < j; i++) {\n        mappers[i].fn(e);\n      }\n    } else {\n      warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n    }\n  }\n  /**\n   * Finds the Container that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x - The x coordinate of the event.\n   * @param y - The y coordinate of the event.\n   */\n  hitTest(x, y) {\n    EventsTicker.pauseUpdate = true;\n    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n    const fn = useMove ? \"hitTestMoveRecursive\" : \"hitTestRecursive\";\n    const invertedPath = this[fn](\n      this.rootTarget,\n      this.rootTarget.eventMode,\n      tempHitLocation.set(x, y),\n      this.hitTestFn,\n      this.hitPruneFn\n    );\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n   * target {@code e.target}.\n   * @param e - The event to propagate.\n   * @param type - The type of event to propagate. Defaults to `e.type`.\n   */\n  propagate(e, type) {\n    if (!e.target) {\n      return;\n    }\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n    e.eventPhase = e.AT_TARGET;\n    e.currentTarget = e.target;\n    this.notifyTarget(e, type);\n    if (e.propagationStopped || e.propagationImmediatelyStopped)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    for (let i = composedPath.length - 2; i >= 0; i--) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n  }\n  /**\n   * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--) {\n      events.forEach((event) => {\n        e.currentTarget = targets[i];\n        this.notifyTarget(e, event);\n      });\n    }\n  }\n  /**\n   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n   * {@code target}. The last element in the path is {@code target}.\n   * @param target - The target to find the propagation path to.\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++) {\n      if (!target.parent) {\n        throw new Error(\"Cannot find propagation path to disconnected target\");\n      }\n      propagationPath.push(target.parent);\n      target = target.parent;\n    }\n    propagationPath.reverse();\n    return propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {\n    let shouldReturn = false;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestMoveRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn,\n          ignore || pruneFn(currentTarget, location)\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) {\n            if (isInteractive)\n              this._allInteractiveElements.push(currentTarget);\n            nestedHit.push(currentTarget);\n          }\n          if (this._hitElements.length === 0)\n            this._hitElements = nestedHit;\n          shouldReturn = true;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveTarget && isInteractiveTarget)\n      this._allInteractiveElements.push(currentTarget);\n    if (ignore || this._hitElements.length > 0)\n      return null;\n    if (shouldReturn)\n      return this._hitElements;\n    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  /**\n   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The Container that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the container.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {\n      return null;\n    }\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      const relativeLocation = location;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          relativeLocation,\n          testFn,\n          pruneFn\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive)\n            nestedHit.push(currentTarget);\n          return nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveMode && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  _isInteractive(int) {\n    return int === \"static\" || int === \"dynamic\";\n  }\n  _interactivePrune(container) {\n    if (!container || !container.visible || !container.renderable || !container.measurable) {\n      return true;\n    }\n    if (container.eventMode === \"none\") {\n      return true;\n    }\n    if (container.eventMode === \"passive\" && !container.interactiveChildren) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container or any of its children cannot pass the hit test at all.\n   *\n   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n   * and {@link Container._maskEffect} for pruning.\n   * @param container - The container to prune.\n   * @param location - The location to test for overlap.\n   */\n  hitPruneFn(container, location) {\n    if (container.hitArea) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n        return true;\n      }\n    }\n    if (container.effects && container.effects.length) {\n      for (let i = 0; i < container.effects.length; i++) {\n        const effect = container.effects[i];\n        if (effect.containsPoint) {\n          const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n          if (!effectContainsPoint) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container passes hit testing for the given location.\n   * @param container - The container to test.\n   * @param location - The location to test for overlap.\n   * @returns - Whether `container` passes hit testing for `location`.\n   */\n  hitTestFn(container, location) {\n    if (container.hitArea) {\n      return true;\n    }\n    if (container?.containsPoint) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      return container.containsPoint(tempLocalMapping);\n    }\n    return false;\n  }\n  /**\n   * Notify all the listeners to the event's `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type - The type of event to notify. Defaults to `e.type`.\n   */\n  notifyTarget(e, type) {\n    if (!e.currentTarget.isInteractive()) {\n      return;\n    }\n    type ?? (type = e.type);\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this._notifyListeners(e, key);\n    if (e.eventPhase === e.AT_TARGET) {\n      this._notifyListeners(e, type);\n    }\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from - The upstream `pointerdown` event.\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerdown\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchstart\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    this._isPointerMoveEvent = true;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = false;\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    const trackingData = this.trackingData(from.pointerId);\n    const outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\";\n      const outEvent = this.createPointerEvent(from, outType, outTarget);\n      this.dispatchEvent(outEvent, \"pointerout\");\n      if (isMouse)\n        this.dispatchEvent(outEvent, \"mouseout\");\n      if (!e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse)\n            this.notifyTarget(leaveEvent, \"mouseleave\");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\";\n      const overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, \"pointerover\");\n      if (isMouse)\n        this.dispatchEvent(overEvent, \"mouseover\");\n      let overTargetAncestor = outTarget?.parent;\n      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n        if (overTargetAncestor === e.target)\n          break;\n        overTargetAncestor = overTargetAncestor.parent;\n      }\n      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n      if (didPointerEnter) {\n        const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n          enterEvent.currentTarget = enterEvent.target;\n          this.notifyTarget(enterEvent);\n          if (isMouse)\n            this.notifyTarget(enterEvent, \"mouseenter\");\n          enterEvent.target = enterEvent.target.parent;\n        }\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [];\n    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n    this.moveOnAll ? allMethods.push(\"pointermove\") : this.dispatchEvent(e, \"pointermove\");\n    allowGlobalPointerEvents && allMethods.push(\"globalpointermove\");\n    if (e.pointerType === \"touch\") {\n      this.moveOnAll ? allMethods.splice(1, 0, \"touchmove\") : this.dispatchEvent(e, \"touchmove\");\n      allowGlobalPointerEvents && allMethods.push(\"globaltouchmove\");\n    }\n    if (isMouse) {\n      this.moveOnAll ? allMethods.splice(1, 0, \"mousemove\") : this.dispatchEvent(e, \"mousemove\");\n      allowGlobalPointerEvents && allMethods.push(\"globalmousemove\");\n      this.cursor = e.target?.cursor;\n    }\n    if (allMethods.length > 0) {\n      this.all(e, allMethods);\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const e = this.createPointerEvent(from);\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    this.dispatchEvent(e, \"pointerover\");\n    if (isMouse)\n      this.dispatchEvent(e, \"mouseover\");\n    if (e.pointerType === \"mouse\")\n      this.cursor = e.target?.cursor;\n    const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n    enterEvent.eventPhase = enterEvent.AT_TARGET;\n    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n      enterEvent.currentTarget = enterEvent.target;\n      this.notifyTarget(enterEvent);\n      if (isMouse)\n        this.notifyTarget(enterEvent, \"mouseenter\");\n      enterEvent.target = enterEvent.target.parent;\n    }\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n    this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\";\n      const outTarget = this.findMountedTarget(trackingData.overTargets);\n      const outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n      this.dispatchEvent(outEvent);\n      if (isMouse)\n        this.dispatchEvent(outEvent, \"mouseout\");\n      const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n      leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n        leaveEvent.currentTarget = leaveEvent.target;\n        this.notifyTarget(leaveEvent);\n        if (isMouse)\n          this.notifyTarget(leaveEvent, \"mouseleave\");\n        leaveEvent.target = leaveEvent.target.parent;\n      }\n      trackingData.overTargets = null;\n      this.freeEvent(outEvent);\n      this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const now = performance.now();\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerup\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchend\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      while (currentTarget && !e.composedPath().includes(currentTarget)) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n      clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, \"click\");\n      clickEvent.target = clickTarget;\n      clickEvent.path = null;\n      if (!trackingData.clicksByButton[from.button]) {\n        trackingData.clicksByButton[from.button] = {\n          clickCount: 0,\n          target: clickEvent.target,\n          timeStamp: now\n        };\n      }\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n        ++clickHistory.clickCount;\n      } else {\n        clickHistory.clickCount = 1;\n      }\n      clickHistory.target = clickEvent.target;\n      clickHistory.timeStamp = now;\n      clickEvent.detail = clickHistory.clickCount;\n      if (clickEvent.pointerType === \"mouse\") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? \"rightclick\" : \"click\");\n      } else if (clickEvent.pointerType === \"touch\") {\n        this.dispatchEvent(clickEvent, \"tap\");\n      }\n      this.dispatchEvent(clickEvent, \"pointertap\");\n      this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    const e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      while (currentTarget) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent)) {\n      warn(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent);\n    this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath) {\n      return null;\n    }\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length; i++) {\n      if (propagationPath[i].parent === currentTarget) {\n        currentTarget = propagationPath[i];\n      } else {\n        break;\n      }\n    }\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The {@code originalEvent} for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];\n    if (typeof type === \"string\") {\n      event.type = type;\n    }\n    return event;\n  }\n  /**\n   * Creates a wheel event whose {@code originalEvent} is {@code from}.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent);\n    this.copyWheelData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = this.hitTest(event.global.x, event.global.y);\n    return event;\n  }\n  /**\n   * Clones the event {@code from}, with an optional {@code type} override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from.originalEvent;\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.target = from.target;\n    event.path = from.composedPath().slice();\n    event.type = type ?? event.type;\n    return event;\n  }\n  /**\n   * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode;\n    to.deltaX = from.deltaX;\n    to.deltaY = from.deltaY;\n    to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyPointerData(from, to) {\n    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))\n      return;\n    to.pointerId = from.pointerId;\n    to.width = from.width;\n    to.height = from.height;\n    to.isPrimary = from.isPrimary;\n    to.pointerType = from.pointerType;\n    to.pressure = from.pressure;\n    to.tangentialPressure = from.tangentialPressure;\n    to.tiltX = from.tiltX;\n    to.tiltY = from.tiltY;\n    to.twist = from.twist;\n  }\n  /**\n   * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyMouseData(from, to) {\n    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))\n      return;\n    to.altKey = from.altKey;\n    to.button = from.button;\n    to.buttons = from.buttons;\n    to.client.copyFrom(from.client);\n    to.ctrlKey = from.ctrlKey;\n    to.metaKey = from.metaKey;\n    to.movement.copyFrom(from.movement);\n    to.screen.copyFrom(from.screen);\n    to.shiftKey = from.shiftKey;\n    to.global.copyFrom(from.global);\n  }\n  /**\n   * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted;\n    to.srcElement = from.srcElement;\n    to.timeStamp = performance.now();\n    to.type = from.type;\n    to.detail = from.detail;\n    to.view = from.view;\n    to.which = from.which;\n    to.layer.copyFrom(from.layer);\n    to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    if (!this.mappingState.trackingData[id]) {\n      this.mappingState.trackingData[id] = {\n        pressTargetsByButton: {},\n        clicksByButton: {},\n        overTarget: null\n      };\n    }\n    return this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event's constructor.\n   */\n  allocateEvent(constructor) {\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    event.eventPhase = event.NONE;\n    event.currentTarget = null;\n    event.defaultPrevented = false;\n    event.path = null;\n    event.target = null;\n    return event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n    const constructor = event.constructor;\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  _notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (!listeners)\n      return;\n    if (\"fn\" in listeners) {\n      if (listeners.once)\n        e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n      listeners.fn.call(listeners.context, e);\n    } else {\n      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n        if (listeners[i].once)\n          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n        listeners[i].fn.call(listeners[i].context, e);\n      }\n    }\n  }\n}\n\nexport { EventBoundary };\n//# sourceMappingURL=EventBoundary.mjs.map\n"],"names":["FederatedEvent","manager","Point","_type","_bubbles","_cancelable","_typeArg","_bubblesArg","_cancelableArg","_viewArg","_detailArg","EventsTickerClass","events","paused","Ticker","UPDATE_PRIORITY","rootPointerEvent","ticker","EventsTicker","FederatedMouseEvent","container","point","globalPos","key","_canBubbleArg","_screenXArg","_screenYArg","_clientXArg","_clientYArg","_ctrlKeyArg","_altKeyArg","_shiftKeyArg","_metaKeyArg","_buttonArg","_relatedTargetArg","FederatedPointerEvent","FederatedWheelEvent","PROPAGATION_LIMIT","tempHitLocation","tempLocalMapping","EventBoundary","rootTarget","EventEmitter","type","fn","a","b","e","mappers","j","warn","x","y","invertedPath","composedPath","i","targets","event","target","propagationPath","currentTarget","eventMode","location","testFn","pruneFn","ignore","shouldReturn","children","child","nestedHit","isInteractive","isInteractiveMode","isInteractiveTarget","relativeLocation","int","effect","handlerKey","from","isRightButton","trackingData","isMouse","outTarget","outType","outEvent","leaveEvent","overType","overEvent","overTargetAncestor","enterEvent","allMethods","allowGlobalPointerEvents","now","pressTarget","clickTarget","clickEvent","clickHistory","wheelEvent","to","id","constructor","listeners"],"mappings":";AAGA,MAAMA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA,EAKnB,YAAYC,GAAS;AAEnB,SAAK,UAAU,IAEf,KAAK,eAAe,IAKpB,KAAK,aAAa,IAMlB,KAAK,WAAW,IAEhB,KAAK,mBAAmB,IAKxB,KAAK,aAAaD,EAAe,UAAU,MAE3C,KAAK,qBAAqB,IAE1B,KAAK,gCAAgC,IAErC,KAAK,QAAQ,IAAIE,EAAO,GAExB,KAAK,OAAO,IAAIA,EAAO,GACvB,KAAK,OAAO,GACZ,KAAK,kBAAkB,GACvB,KAAK,YAAY,GACjB,KAAK,iBAAiB,GACtB,KAAK,UAAUD;AAAA,EACnB;AAAA;AAAA,EAEE,IAAI,SAAS;AACX,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA;AAAA,EAEE,IAAI,SAAS;AACX,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA;AAAA,EAEE,IAAI,QAAQ;AACV,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA;AAAA,EAEE,IAAI,QAAQ;AACV,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,IAAI,OAAO;AACT,WAAO;AAAA,EACX;AAAA;AAAA,EAEE,eAAe;AACb,WAAI,KAAK,YAAY,CAAC,KAAK,QAAQ,KAAK,KAAK,KAAK,KAAK,SAAS,CAAC,MAAM,KAAK,YAC1E,KAAK,OAAO,KAAK,SAAS,KAAK,QAAQ,gBAAgB,KAAK,MAAM,IAAI,CAAE,IAEnE,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,UAAUE,GAAOC,GAAUC,GAAa;AACtC,UAAM,IAAI,MAAM,qFAAqF;AAAA,EACzG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUE,YAAYC,GAAUC,GAAaC,GAAgBC,GAAUC,GAAY;AACvE,UAAM,IAAI,MAAM,uFAAuF;AAAA,EAC3G;AAAA;AAAA,EAEE,iBAAiB;AACf,IAAI,KAAK,uBAAuB,SAAS,KAAK,YAAY,cACxD,KAAK,YAAY,eAAgB,GAEnC,KAAK,mBAAmB;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,2BAA2B;AACzB,SAAK,gCAAgC;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,kBAAkB;AAChB,SAAK,qBAAqB;AAAA,EAC9B;AACA;ACnHA,MAAMC,EAAkB;AAAA,EACtB,cAAc;AAEZ,SAAK,uBAAuB,IAC5B,KAAK,aAAa,GAClB,KAAK,WAAW,IAChB,KAAK,eAAe,IACpB,KAAK,eAAe;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,KAAKC,GAAQ;AACX,SAAK,qBAAsB,GAC3B,KAAK,SAASA,GACd,KAAK,uBAAuB,IAC5B,KAAK,aAAa,GAClB,KAAK,WAAW,IAChB,KAAK,eAAe,IACpB,KAAK,eAAe;AAAA,EACxB;AAAA;AAAA,EAEE,IAAI,cAAc;AAChB,WAAO,KAAK;AAAA,EAChB;AAAA,EACE,IAAI,YAAYC,GAAQ;AACtB,SAAK,eAAeA;AAAA,EACxB;AAAA;AAAA,EAEE,oBAAoB;AAClB,IAAI,KAAK,gBAAgB,CAAC,KAAK,eAG/BC,EAAO,OAAO,IAAI,KAAK,eAAe,MAAMC,EAAgB,WAAW,GACvE,KAAK,eAAe;AAAA,EACxB;AAAA;AAAA,EAEE,uBAAuB;AACrB,IAAK,KAAK,iBAGVD,EAAO,OAAO,OAAO,KAAK,eAAe,IAAI,GAC7C,KAAK,eAAe;AAAA,EACxB;AAAA;AAAA,EAEE,eAAe;AACb,SAAK,WAAW;AAAA,EACpB;AAAA;AAAA,EAEE,UAAU;AACR,QAAI,CAAC,KAAK,cAAc,KAAK;AAC3B;AAEF,QAAI,KAAK,UAAU;AACjB,WAAK,WAAW;AAChB;AAAA,IACN;AACI,UAAME,IAAmB,KAAK,OAAO;AACrC,IAAI,KAAK,OAAO,uBAAuBA,EAAiB,gBAAgB,WAGxE,WAAW,SAAS,cAAc,IAAI,aAAa,eAAe;AAAA,MAChE,SAASA,EAAiB;AAAA,MAC1B,SAASA,EAAiB;AAAA,MAC1B,aAAaA,EAAiB;AAAA,MAC9B,WAAWA,EAAiB;AAAA,IAClC,CAAK,CAAC;AAAA,EACN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,cAAcC,GAAQ;AAEpB,IADA,KAAK,cAAcA,EAAO,WACtB,OAAK,aAAa,KAAK,0BAG3B,KAAK,aAAa,GAClB,KAAK,QAAS;AAAA,EAClB;AACA;AACK,MAACC,IAAe,IAAIP,EAAiB;ACrF1C,MAAMQ,UAA4BnB,EAAe;AAAA,EAC/C,cAAc;AACZ,UAAM,GAAG,SAAS,GAElB,KAAK,SAAS,IAAIE,EAAO,GAEzB,KAAK,WAAW,IAAIA,EAAO,GAE3B,KAAK,SAAS,IAAIA,EAAO,GAEzB,KAAK,SAAS,IAAIA,EAAO,GAKzB,KAAK,SAAS,IAAIA,EAAO;AAAA,EAC7B;AAAA;AAAA,EAEE,IAAI,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA,EAEE,IAAI,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,IAAI,IAAI;AACN,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,IAAI,IAAI;AACN,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAEE,IAAI,YAAY;AACd,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA;AAAA,EAEE,IAAI,YAAY;AACd,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA;AAAA,EAEE,IAAI,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA,EAEE,IAAI,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA,EAEE,IAAI,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA,EAEE,IAAI,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,IAAI,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,IAAI,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYE,iBAAiBkB,GAAWC,GAAOC,GAAW;AAC5C,WAAOF,EAAU,eAAe,aAAaE,KAAa,KAAK,QAAQD,CAAK;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,iBAAiBE,GAAK;AACpB,WAAO,sBAAsB,KAAK,eAAe,KAAK,YAAY,iBAAiBA,CAAG;AAAA,EAC1F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBE,eAAejB,GAAUkB,GAAehB,GAAgBC,GAAUC,GAAYe,GAAaC,GAAaC,GAAaC,GAAaC,GAAaC,GAAYC,GAAcC,GAAaC,GAAYC,GAAmB;AACnN,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AACA;AC1HA,MAAMC,UAA8BhB,EAAoB;AAAA,EACtD,cAAc;AACZ,UAAM,GAAG,SAAS,GAMlB,KAAK,QAAQ,GAMb,KAAK,SAAS,GAKd,KAAK,YAAY;AAAA,EACrB;AAAA;AAAA,EAEE,qBAAqB;AACnB,WAAI,KAAK,SAAS,iBAAiB,KAAK,SAAS,eAAe,KAAK,SAAS,cACrE,CAAC,IAAI,IAEP,CAAE;AAAA,EACb;AAAA;AAAA,EAEE,qBAAqB;AACnB,UAAM,IAAI,MAAM,sCAAsC;AAAA,EAC1D;AACA;AChCA,MAAMiB,UAA4BjB,EAAoB;AAAA,EACpD,cAAc;AACZ,UAAM,GAAG,SAAS,GAElB,KAAK,kBAAkB,GAEvB,KAAK,iBAAiB,GAEtB,KAAK,iBAAiB;AAAA,EAC1B;AACA;AAEAiB,EAAoB,kBAAkB;AAEtCA,EAAoB,iBAAiB;AAErCA,EAAoB,iBAAiB;ACVrC,MAAMC,IAAoB,MACpBC,IAAkB,IAAIpC,EAAO,GAC7BqC,IAAmB,IAAIrC,EAAO;AACpC,MAAMsC,EAAc;AAAA;AAAA;AAAA;AAAA,EAIlB,YAAYC,GAAY;AAUtB,SAAK,WAAW,IAAIC,EAAc,GAOlC,KAAK,YAAY,IAEjB,KAAK,yBAAyB,IAK9B,KAAK,eAAe;AAAA,MAClB,cAAc,CAAA;AAAA,IACf,GAMD,KAAK,YAA4B,oBAAI,IAAK,GAE1C,KAAK,0BAA0B,CAAE,GAEjC,KAAK,eAAe,CAAE,GAEtB,KAAK,sBAAsB,IAC3B,KAAK,aAAaD,GAClB,KAAK,aAAa,KAAK,WAAW,KAAK,IAAI,GAC3C,KAAK,YAAY,KAAK,UAAU,KAAK,IAAI,GACzC,KAAK,iBAAiB,KAAK,eAAe,KAAK,IAAI,GACnD,KAAK,iBAAiB,KAAK,eAAe,KAAK,IAAI,GACnD,KAAK,gBAAgB,KAAK,cAAc,KAAK,IAAI,GACjD,KAAK,iBAAiB,KAAK,eAAe,KAAK,IAAI,GACnD,KAAK,eAAe,KAAK,aAAa,KAAK,IAAI,GAC/C,KAAK,sBAAsB,KAAK,oBAAoB,KAAK,IAAI,GAC7D,KAAK,WAAW,KAAK,SAAS,KAAK,IAAI,GACvC,KAAK,eAAe,CAAE,GACtB,KAAK,gBAAgB,eAAe,KAAK,cAAc,GACvD,KAAK,gBAAgB,eAAe,KAAK,cAAc,GACvD,KAAK,gBAAgB,cAAc,KAAK,aAAa,GACrD,KAAK,gBAAgB,gBAAgB,KAAK,aAAa,GACvD,KAAK,gBAAgB,eAAe,KAAK,cAAc,GACvD,KAAK,gBAAgB,aAAa,KAAK,YAAY,GACnD,KAAK,gBAAgB,oBAAoB,KAAK,mBAAmB,GACjE,KAAK,gBAAgB,SAAS,KAAK,QAAQ;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaE,gBAAgBE,GAAMC,GAAI;AACxB,IAAK,KAAK,aAAaD,CAAI,MACzB,KAAK,aAAaA,CAAI,IAAI,CAAE,IAE9B,KAAK,aAAaA,CAAI,EAAE,KAAK;AAAA,MAC3B,IAAAC;AAAA,MACA,UAAU;AAAA,IAChB,CAAK,GACD,KAAK,aAAaD,CAAI,EAAE,KAAK,CAACE,GAAGC,MAAMD,EAAE,WAAWC,EAAE,QAAQ;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,cAAcC,GAAGJ,GAAM;AACrB,IAAAI,EAAE,qBAAqB,IACvBA,EAAE,gCAAgC,IAClC,KAAK,UAAUA,GAAGJ,CAAI,GACtB,KAAK,SAAS,KAAKA,KAAQI,EAAE,MAAMA,CAAC;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,SAASA,GAAG;AACV,QAAI,CAAC,KAAK;AACR;AAEF,UAAMC,IAAU,KAAK,aAAaD,EAAE,IAAI;AACxC,QAAIC;AACF,eAAS,IAAI,GAAGC,IAAID,EAAQ,QAAQ,IAAIC,GAAG;AACzC,QAAAD,EAAQ,CAAC,EAAE,GAAGD,CAAC;AAAA;AAGjB,MAAAG,EAAK,kDAAkDH,EAAE,IAAI,EAAE;AAAA,EAErE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,QAAQI,GAAGC,GAAG;AACZ,IAAAlC,EAAa,cAAc;AAE3B,UAAM0B,IADU,KAAK,uBAAuB,KAAK,yBAC5B,yBAAyB,oBACxCS,IAAe,KAAKT,CAAE;AAAA,MAC1B,KAAK;AAAA,MACL,KAAK,WAAW;AAAA,MAChBN,EAAgB,IAAIa,GAAGC,CAAC;AAAA,MACxB,KAAK;AAAA,MACL,KAAK;AAAA,IACN;AACD,WAAOC,KAAgBA,EAAa,CAAC;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,UAAUN,GAAGJ,GAAM;AACjB,QAAI,CAACI,EAAE;AACL;AAEF,UAAMO,IAAeP,EAAE,aAAc;AACrC,IAAAA,EAAE,aAAaA,EAAE;AACjB,aAASQ,IAAI,GAAGN,IAAIK,EAAa,SAAS,GAAGC,IAAIN,GAAGM;AAGlD,UAFAR,EAAE,gBAAgBO,EAAaC,CAAC,GAChC,KAAK,aAAaR,GAAGJ,CAAI,GACrBI,EAAE,sBAAsBA,EAAE;AAC5B;AAKJ,QAHAA,EAAE,aAAaA,EAAE,WACjBA,EAAE,gBAAgBA,EAAE,QACpB,KAAK,aAAaA,GAAGJ,CAAI,GACrB,EAAAI,EAAE,sBAAsBA,EAAE,gCAE9B;AAAA,MAAAA,EAAE,aAAaA,EAAE;AACjB,eAASQ,IAAID,EAAa,SAAS,GAAGC,KAAK,GAAGA;AAG5C,YAFAR,EAAE,gBAAgBO,EAAaC,CAAC,GAChC,KAAK,aAAaR,GAAGJ,CAAI,GACrBI,EAAE,sBAAsBA,EAAE;AAC5B;AAAA;AAAA,EAER;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASE,IAAIA,GAAGJ,GAAMa,IAAU,KAAK,yBAAyB;AACnD,QAAIA,EAAQ,WAAW;AACrB;AACF,IAAAT,EAAE,aAAaA,EAAE;AACjB,UAAMnC,IAAS,MAAM,QAAQ+B,CAAI,IAAIA,IAAO,CAACA,CAAI;AACjD,aAASY,IAAIC,EAAQ,SAAS,GAAGD,KAAK,GAAGA;AACvC,MAAA3C,EAAO,QAAQ,CAAC6C,MAAU;AACxB,QAAAV,EAAE,gBAAgBS,EAAQD,CAAC,GAC3B,KAAK,aAAaR,GAAGU,CAAK;AAAA,MAClC,CAAO;AAAA,EAEP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,gBAAgBC,GAAQ;AACtB,UAAMC,IAAkB,CAACD,CAAM;AAC/B,aAAS,IAAI,GAAG,IAAIrB,KAAsBqB,MAAW,KAAK,cAAcA,EAAO,QAAS,KAAK;AAC3F,UAAI,CAACA,EAAO;AACV,cAAM,IAAI,MAAM,qDAAqD;AAEvE,MAAAC,EAAgB,KAAKD,EAAO,MAAM,GAClCA,IAASA,EAAO;AAAA,IACtB;AACI,WAAAC,EAAgB,QAAS,GAClBA;AAAA,EACX;AAAA,EACE,qBAAqBC,GAAeC,GAAWC,GAAUC,GAAQC,GAASC,IAAS,IAAO;AACxF,QAAIC,IAAe;AACnB,QAAI,KAAK,kBAAkBN,CAAa;AACtC,aAAO;AAIT,SAHIA,EAAc,cAAc,aAAaC,MAAc,eACzD3C,EAAa,cAAc,KAEzB0C,EAAc,uBAAuBA,EAAc,UAAU;AAC/D,YAAMO,IAAWP,EAAc;AAC/B,eAASL,IAAIY,EAAS,SAAS,GAAGZ,KAAK,GAAGA,KAAK;AAC7C,cAAMa,IAAQD,EAASZ,CAAC,GAClBc,IAAY,KAAK;AAAA,UACrBD;AAAA,UACA,KAAK,eAAeP,CAAS,IAAIA,IAAYO,EAAM;AAAA,UACnDN;AAAA,UACAC;AAAA,UACAC;AAAA,UACAC,KAAUD,EAAQJ,GAAeE,CAAQ;AAAA,QAC1C;AACD,YAAIO,GAAW;AACb,cAAIA,EAAU,SAAS,KAAK,CAACA,EAAUA,EAAU,SAAS,CAAC,EAAE;AAC3D;AAEF,gBAAMC,IAAgBV,EAAc,cAAe;AACnD,WAAIS,EAAU,SAAS,KAAKC,OACtBA,KACF,KAAK,wBAAwB,KAAKV,CAAa,GACjDS,EAAU,KAAKT,CAAa,IAE1B,KAAK,aAAa,WAAW,MAC/B,KAAK,eAAeS,IACtBH,IAAe;AAAA,QACzB;AAAA,MACA;AAAA,IACA;AACI,UAAMK,IAAoB,KAAK,eAAeV,CAAS,GACjDW,IAAsBZ,EAAc,cAAe;AAGzD,WAFIY,KAAuBA,KACzB,KAAK,wBAAwB,KAAKZ,CAAa,GAC7CK,KAAU,KAAK,aAAa,SAAS,IAChC,OACLC,IACK,KAAK,eACVK,KAAsB,CAACP,EAAQJ,GAAeE,CAAQ,KAAKC,EAAOH,GAAeE,CAAQ,IACpFU,IAAsB,CAACZ,CAAa,IAAI,CAAE,IAE5C;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeE,iBAAiBA,GAAeC,GAAWC,GAAUC,GAAQC,GAAS;AACpE,QAAI,KAAK,kBAAkBJ,CAAa,KAAKI,EAAQJ,GAAeE,CAAQ;AAC1E,aAAO;AAKT,SAHIF,EAAc,cAAc,aAAaC,MAAc,eACzD3C,EAAa,cAAc,KAEzB0C,EAAc,uBAAuBA,EAAc,UAAU;AAC/D,YAAMO,IAAWP,EAAc,UACzBa,IAAmBX;AACzB,eAASP,IAAIY,EAAS,SAAS,GAAGZ,KAAK,GAAGA,KAAK;AAC7C,cAAMa,IAAQD,EAASZ,CAAC,GAClBc,IAAY,KAAK;AAAA,UACrBD;AAAA,UACA,KAAK,eAAeP,CAAS,IAAIA,IAAYO,EAAM;AAAA,UACnDK;AAAA,UACAV;AAAA,UACAC;AAAA,QACD;AACD,YAAIK,GAAW;AACb,cAAIA,EAAU,SAAS,KAAK,CAACA,EAAUA,EAAU,SAAS,CAAC,EAAE;AAC3D;AAEF,gBAAMC,IAAgBV,EAAc,cAAe;AACnD,kBAAIS,EAAU,SAAS,KAAKC,MAC1BD,EAAU,KAAKT,CAAa,GACvBS;AAAA,QACjB;AAAA,MACA;AAAA,IACA;AACI,UAAME,IAAoB,KAAK,eAAeV,CAAS,GACjDW,IAAsBZ,EAAc,cAAe;AACzD,WAAIW,KAAqBR,EAAOH,GAAeE,CAAQ,IAC9CU,IAAsB,CAACZ,CAAa,IAAI,CAAE,IAE5C;AAAA,EACX;AAAA,EACE,eAAec,GAAK;AAClB,WAAOA,MAAQ,YAAYA,MAAQ;AAAA,EACvC;AAAA,EACE,kBAAkBtD,GAAW;AAO3B,WANI,CAACA,KAAa,CAACA,EAAU,WAAW,CAACA,EAAU,cAAc,CAACA,EAAU,cAGxEA,EAAU,cAAc,UAGxBA,EAAU,cAAc,aAAa,CAACA,EAAU;AAAA,EAIxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASE,WAAWA,GAAW0C,GAAU;AAC9B,QAAI1C,EAAU,YACZA,EAAU,eAAe,aAAa0C,GAAUvB,CAAgB,GAC5D,CAACnB,EAAU,QAAQ,SAASmB,EAAiB,GAAGA,EAAiB,CAAC;AACpE,aAAO;AAGX,QAAInB,EAAU,WAAWA,EAAU,QAAQ;AACzC,eAAS,IAAI,GAAG,IAAIA,EAAU,QAAQ,QAAQ,KAAK;AACjD,cAAMuD,IAASvD,EAAU,QAAQ,CAAC;AAClC,YAAIuD,EAAO,iBAEL,CADwBA,EAAO,cAAcb,GAAU,KAAK,SAAS;AAEvE,iBAAO;AAAA,MAGnB;AAEI,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,UAAU1C,GAAW0C,GAAU;AAC7B,WAAI1C,EAAU,UACL,KAELA,GAAW,iBACbA,EAAU,eAAe,aAAa0C,GAAUvB,CAAgB,GACzDnB,EAAU,cAAcmB,CAAgB,KAE1C;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASE,aAAaQ,GAAGJ,GAAM;AACpB,QAAI,CAACI,EAAE,cAAc;AACnB;AAEF,IAAAJ,MAASA,IAAOI,EAAE;AAClB,UAAM6B,IAAa,KAAKjC,CAAI;AAC5B,IAAAI,EAAE,cAAc6B,CAAU,IAAI7B,CAAC;AAC/B,UAAMxB,IAAMwB,EAAE,eAAeA,EAAE,mBAAmBA,EAAE,eAAeA,EAAE,YAAY,GAAGJ,CAAI,YAAYA;AACpG,SAAK,iBAAiBI,GAAGxB,CAAG,GACxBwB,EAAE,eAAeA,EAAE,aACrB,KAAK,iBAAiBA,GAAGJ,CAAI;AAAA,EAEnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,eAAekC,GAAM;AACnB,QAAI,EAAEA,aAAgB1C,IAAwB;AAC5C,MAAAe,EAAK,iEAAiE;AACtE;AAAA,IACN;AACI,UAAM,IAAI,KAAK,mBAAmB2B,CAAI;AAEtC,QADA,KAAK,cAAc,GAAG,aAAa,GAC/B,EAAE,gBAAgB;AACpB,WAAK,cAAc,GAAG,YAAY;AAAA,aACzB,EAAE,gBAAgB,WAAW,EAAE,gBAAgB,OAAO;AAC/D,YAAMC,IAAgB,EAAE,WAAW;AACnC,WAAK,cAAc,GAAGA,IAAgB,cAAc,WAAW;AAAA,IACrE;AACI,UAAMC,IAAe,KAAK,aAAaF,EAAK,SAAS;AACrD,IAAAE,EAAa,qBAAqBF,EAAK,MAAM,IAAI,EAAE,aAAc,GACjE,KAAK,UAAU,CAAC;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,eAAeA,GAAM;AACnB,QAAI,EAAEA,aAAgB1C,IAAwB;AAC5C,MAAAe,EAAK,iEAAiE;AACtE;AAAA,IACN;AACI,SAAK,wBAAwB,SAAS,GACtC,KAAK,aAAa,SAAS,GAC3B,KAAK,sBAAsB;AAC3B,UAAM,IAAI,KAAK,mBAAmB2B,CAAI;AACtC,SAAK,sBAAsB;AAC3B,UAAMG,IAAU,EAAE,gBAAgB,WAAW,EAAE,gBAAgB,OACzDD,IAAe,KAAK,aAAaF,EAAK,SAAS,GAC/CI,IAAY,KAAK,kBAAkBF,EAAa,WAAW;AACjE,QAAIA,EAAa,aAAa,SAAS,KAAKE,MAAc,EAAE,QAAQ;AAClE,YAAMC,IAAUL,EAAK,SAAS,cAAc,aAAa,cACnDM,IAAW,KAAK,mBAAmBN,GAAMK,GAASD,CAAS;AAIjE,UAHA,KAAK,cAAcE,GAAU,YAAY,GACrCH,KACF,KAAK,cAAcG,GAAU,UAAU,GACrC,CAAC,EAAE,aAAc,EAAC,SAASF,CAAS,GAAG;AACzC,cAAMG,IAAa,KAAK,mBAAmBP,GAAM,gBAAgBI,CAAS;AAE1E,aADAG,EAAW,aAAaA,EAAW,WAC5BA,EAAW,UAAU,CAAC,EAAE,aAAY,EAAG,SAASA,EAAW,MAAM;AACtE,UAAAA,EAAW,gBAAgBA,EAAW,QACtC,KAAK,aAAaA,CAAU,GACxBJ,KACF,KAAK,aAAaI,GAAY,YAAY,GAC5CA,EAAW,SAASA,EAAW,OAAO;AAExC,aAAK,UAAUA,CAAU;AAAA,MACjC;AACM,WAAK,UAAUD,CAAQ;AAAA,IAC7B;AACI,QAAIF,MAAc,EAAE,QAAQ;AAC1B,YAAMI,IAAWR,EAAK,SAAS,cAAc,cAAc,eACrDS,IAAY,KAAK,kBAAkB,GAAGD,CAAQ;AACpD,WAAK,cAAcC,GAAW,aAAa,GACvCN,KACF,KAAK,cAAcM,GAAW,WAAW;AAC3C,UAAIC,IAAqBN,GAAW;AACpC,aAAOM,KAAsBA,MAAuB,KAAK,WAAW,UAC9DA,MAAuB,EAAE;AAE7B,QAAAA,IAAqBA,EAAmB;AAG1C,UADwB,CAACA,KAAsBA,MAAuB,KAAK,WAAW,QACjE;AACnB,cAAMC,IAAa,KAAK,kBAAkB,GAAG,cAAc;AAE3D,aADAA,EAAW,aAAaA,EAAW,WAC5BA,EAAW,UAAUA,EAAW,WAAWP,KAAaO,EAAW,WAAW,KAAK,WAAW;AACnG,UAAAA,EAAW,gBAAgBA,EAAW,QACtC,KAAK,aAAaA,CAAU,GACxBR,KACF,KAAK,aAAaQ,GAAY,YAAY,GAC5CA,EAAW,SAASA,EAAW,OAAO;AAExC,aAAK,UAAUA,CAAU;AAAA,MACjC;AACM,WAAK,UAAUF,CAAS;AAAA,IAC9B;AACI,UAAMG,IAAa,CAAE,GACfC,IAA2B,KAAK,0BAA0B;AAChE,SAAK,YAAYD,EAAW,KAAK,aAAa,IAAI,KAAK,cAAc,GAAG,aAAa,GACrFC,KAA4BD,EAAW,KAAK,mBAAmB,GAC3D,EAAE,gBAAgB,YACpB,KAAK,YAAYA,EAAW,OAAO,GAAG,GAAG,WAAW,IAAI,KAAK,cAAc,GAAG,WAAW,GACzFC,KAA4BD,EAAW,KAAK,iBAAiB,IAE3DT,MACF,KAAK,YAAYS,EAAW,OAAO,GAAG,GAAG,WAAW,IAAI,KAAK,cAAc,GAAG,WAAW,GACzFC,KAA4BD,EAAW,KAAK,iBAAiB,GAC7D,KAAK,SAAS,EAAE,QAAQ,SAEtBA,EAAW,SAAS,KACtB,KAAK,IAAI,GAAGA,CAAU,GAExB,KAAK,wBAAwB,SAAS,GACtC,KAAK,aAAa,SAAS,GAC3BV,EAAa,cAAc,EAAE,aAAc,GAC3C,KAAK,UAAU,CAAC;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,eAAeF,GAAM;AACnB,QAAI,EAAEA,aAAgB1C,IAAwB;AAC5C,MAAAe,EAAK,iEAAiE;AACtE;AAAA,IACN;AACI,UAAM6B,IAAe,KAAK,aAAaF,EAAK,SAAS,GAC/C9B,IAAI,KAAK,mBAAmB8B,CAAI,GAChCG,IAAUjC,EAAE,gBAAgB,WAAWA,EAAE,gBAAgB;AAC/D,SAAK,cAAcA,GAAG,aAAa,GAC/BiC,KACF,KAAK,cAAcjC,GAAG,WAAW,GAC/BA,EAAE,gBAAgB,YACpB,KAAK,SAASA,EAAE,QAAQ;AAC1B,UAAMyC,IAAa,KAAK,kBAAkBzC,GAAG,cAAc;AAE3D,SADAyC,EAAW,aAAaA,EAAW,WAC5BA,EAAW,UAAUA,EAAW,WAAW,KAAK,WAAW;AAChE,MAAAA,EAAW,gBAAgBA,EAAW,QACtC,KAAK,aAAaA,CAAU,GACxBR,KACF,KAAK,aAAaQ,GAAY,YAAY,GAC5CA,EAAW,SAASA,EAAW,OAAO;AAExC,IAAAT,EAAa,cAAchC,EAAE,aAAc,GAC3C,KAAK,UAAUA,CAAC,GAChB,KAAK,UAAUyC,CAAU;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,cAAcX,GAAM;AAClB,QAAI,EAAEA,aAAgB1C,IAAwB;AAC5C,MAAAe,EAAK,iEAAiE;AACtE;AAAA,IACN;AACI,UAAM6B,IAAe,KAAK,aAAaF,EAAK,SAAS;AACrD,QAAIE,EAAa,aAAa;AAC5B,YAAMC,IAAUH,EAAK,gBAAgB,WAAWA,EAAK,gBAAgB,OAC/DI,IAAY,KAAK,kBAAkBF,EAAa,WAAW,GAC3DI,IAAW,KAAK,mBAAmBN,GAAM,cAAcI,CAAS;AACtE,WAAK,cAAcE,CAAQ,GACvBH,KACF,KAAK,cAAcG,GAAU,UAAU;AACzC,YAAMC,IAAa,KAAK,mBAAmBP,GAAM,gBAAgBI,CAAS;AAE1E,WADAG,EAAW,aAAaA,EAAW,WAC5BA,EAAW,UAAUA,EAAW,WAAW,KAAK,WAAW;AAChE,QAAAA,EAAW,gBAAgBA,EAAW,QACtC,KAAK,aAAaA,CAAU,GACxBJ,KACF,KAAK,aAAaI,GAAY,YAAY,GAC5CA,EAAW,SAASA,EAAW,OAAO;AAExC,MAAAL,EAAa,cAAc,MAC3B,KAAK,UAAUI,CAAQ,GACvB,KAAK,UAAUC,CAAU;AAAA,IAC/B;AACI,SAAK,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWE,aAAaP,GAAM;AACjB,QAAI,EAAEA,aAAgB1C,IAAwB;AAC5C,MAAAe,EAAK,iEAAiE;AACtE;AAAA,IACN;AACI,UAAMyC,IAAM,YAAY,IAAK,GACvB5C,IAAI,KAAK,mBAAmB8B,CAAI;AAEtC,QADA,KAAK,cAAc9B,GAAG,WAAW,GAC7BA,EAAE,gBAAgB;AACpB,WAAK,cAAcA,GAAG,UAAU;AAAA,aACvBA,EAAE,gBAAgB,WAAWA,EAAE,gBAAgB,OAAO;AAC/D,YAAM+B,IAAgB/B,EAAE,WAAW;AACnC,WAAK,cAAcA,GAAG+B,IAAgB,YAAY,SAAS;AAAA,IACjE;AACI,UAAMC,IAAe,KAAK,aAAaF,EAAK,SAAS,GAC/Ce,IAAc,KAAK,kBAAkBb,EAAa,qBAAqBF,EAAK,MAAM,CAAC;AACzF,QAAIgB,IAAcD;AAClB,QAAIA,KAAe,CAAC7C,EAAE,aAAY,EAAG,SAAS6C,CAAW,GAAG;AAC1D,UAAIhC,IAAgBgC;AACpB,aAAOhC,KAAiB,CAACb,EAAE,aAAY,EAAG,SAASa,CAAa,KAAG;AAGjE,YAFAb,EAAE,gBAAgBa,GAClB,KAAK,aAAab,GAAG,kBAAkB,GACnCA,EAAE,gBAAgB;AACpB,eAAK,aAAaA,GAAG,iBAAiB;AAAA,iBAC7BA,EAAE,gBAAgB,WAAWA,EAAE,gBAAgB,OAAO;AAC/D,gBAAM+B,IAAgB/B,EAAE,WAAW;AACnC,eAAK,aAAaA,GAAG+B,IAAgB,mBAAmB,gBAAgB;AAAA,QAClF;AACQ,QAAAlB,IAAgBA,EAAc;AAAA,MACtC;AACM,aAAOmB,EAAa,qBAAqBF,EAAK,MAAM,GACpDgB,IAAcjC;AAAA,IACpB;AACI,QAAIiC,GAAa;AACf,YAAMC,IAAa,KAAK,kBAAkB/C,GAAG,OAAO;AACpD,MAAA+C,EAAW,SAASD,GACpBC,EAAW,OAAO,MACbf,EAAa,eAAeF,EAAK,MAAM,MAC1CE,EAAa,eAAeF,EAAK,MAAM,IAAI;AAAA,QACzC,YAAY;AAAA,QACZ,QAAQiB,EAAW;AAAA,QACnB,WAAWH;AAAA,MACZ;AAEH,YAAMI,IAAehB,EAAa,eAAeF,EAAK,MAAM;AAS5D,UARIkB,EAAa,WAAWD,EAAW,UAAUH,IAAMI,EAAa,YAAY,MAC9E,EAAEA,EAAa,aAEfA,EAAa,aAAa,GAE5BA,EAAa,SAASD,EAAW,QACjCC,EAAa,YAAYJ,GACzBG,EAAW,SAASC,EAAa,YAC7BD,EAAW,gBAAgB,SAAS;AACtC,cAAMhB,IAAgBgB,EAAW,WAAW;AAC5C,aAAK,cAAcA,GAAYhB,IAAgB,eAAe,OAAO;AAAA,MAC7E,MAAa,CAAIgB,EAAW,gBAAgB,WACpC,KAAK,cAAcA,GAAY,KAAK;AAEtC,WAAK,cAAcA,GAAY,YAAY,GAC3C,KAAK,UAAUA,CAAU;AAAA,IAC/B;AACI,SAAK,UAAU/C,CAAC;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYE,oBAAoB8B,GAAM;AACxB,QAAI,EAAEA,aAAgB1C,IAAwB;AAC5C,MAAAe,EAAK,iEAAiE;AACtE;AAAA,IACN;AACI,UAAM6B,IAAe,KAAK,aAAaF,EAAK,SAAS,GAC/Ce,IAAc,KAAK,kBAAkBb,EAAa,qBAAqBF,EAAK,MAAM,CAAC,GACnF9B,IAAI,KAAK,mBAAmB8B,CAAI;AACtC,QAAIe,GAAa;AACf,UAAIhC,IAAgBgC;AACpB,aAAOhC;AACL,QAAAb,EAAE,gBAAgBa,GAClB,KAAK,aAAab,GAAG,kBAAkB,GACnCA,EAAE,gBAAgB,UACpB,KAAK,aAAaA,GAAG,iBAAiB,KAC7BA,EAAE,gBAAgB,WAAWA,EAAE,gBAAgB,UACxD,KAAK,aAAaA,GAAGA,EAAE,WAAW,IAAI,mBAAmB,gBAAgB,GAE3Ea,IAAgBA,EAAc;AAEhC,aAAOmB,EAAa,qBAAqBF,EAAK,MAAM;AAAA,IAC1D;AACI,SAAK,UAAU9B,CAAC;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKE,SAAS8B,GAAM;AACb,QAAI,EAAEA,aAAgBzC,IAAsB;AAC1C,MAAAc,EAAK,6DAA6D;AAClE;AAAA,IACN;AACI,UAAM8C,IAAa,KAAK,iBAAiBnB,CAAI;AAC7C,SAAK,cAAcmB,CAAU,GAC7B,KAAK,UAAUA,CAAU;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASE,kBAAkBrC,GAAiB;AACjC,QAAI,CAACA;AACH,aAAO;AAET,QAAIC,IAAgBD,EAAgB,CAAC;AACrC,aAAS,IAAI,GAAG,IAAIA,EAAgB,UAC9BA,EAAgB,CAAC,EAAE,WAAWC,GADQ;AAExC,MAAAA,IAAgBD,EAAgB,CAAC;AAKrC,WAAOC;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASE,mBAAmBiB,GAAMlC,GAAMe,GAAQ;AACrC,UAAMD,IAAQ,KAAK,cAActB,CAAqB;AACtD,gBAAK,gBAAgB0C,GAAMpB,CAAK,GAChC,KAAK,cAAcoB,GAAMpB,CAAK,GAC9B,KAAK,SAASoB,GAAMpB,CAAK,GACzBA,EAAM,cAAcoB,EAAK,aACzBpB,EAAM,gBAAgBoB,GACtBpB,EAAM,SAASC,KAAU,KAAK,QAAQD,EAAM,OAAO,GAAGA,EAAM,OAAO,CAAC,KAAK,KAAK,aAAa,CAAC,GACxF,OAAOd,KAAS,aAClBc,EAAM,OAAOd,IAERc;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,iBAAiBoB,GAAM;AACrB,UAAMpB,IAAQ,KAAK,cAAcrB,CAAmB;AACpD,gBAAK,cAAcyC,GAAMpB,CAAK,GAC9B,KAAK,cAAcoB,GAAMpB,CAAK,GAC9B,KAAK,SAASoB,GAAMpB,CAAK,GACzBA,EAAM,cAAcoB,EAAK,aACzBpB,EAAM,gBAAgBoB,GACtBpB,EAAM,SAAS,KAAK,QAAQA,EAAM,OAAO,GAAGA,EAAM,OAAO,CAAC,GACnDA;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,kBAAkBoB,GAAMlC,GAAM;AAC5B,UAAMc,IAAQ,KAAK,cAActB,CAAqB;AACtD,WAAAsB,EAAM,cAAcoB,EAAK,aACzBpB,EAAM,gBAAgBoB,EAAK,eAC3B,KAAK,gBAAgBA,GAAMpB,CAAK,GAChC,KAAK,cAAcoB,GAAMpB,CAAK,GAC9B,KAAK,SAASoB,GAAMpB,CAAK,GACzBA,EAAM,SAASoB,EAAK,QACpBpB,EAAM,OAAOoB,EAAK,aAAY,EAAG,MAAO,GACxCpB,EAAM,OAAOd,KAAQc,EAAM,MACpBA;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYE,cAAcoB,GAAMoB,GAAI;AACtB,IAAAA,EAAG,YAAYpB,EAAK,WACpBoB,EAAG,SAASpB,EAAK,QACjBoB,EAAG,SAASpB,EAAK,QACjBoB,EAAG,SAASpB,EAAK;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBE,gBAAgBA,GAAMoB,GAAI;AACxB,IAAMpB,aAAgB1C,KAAyB8D,aAAc9D,MAE7D8D,EAAG,YAAYpB,EAAK,WACpBoB,EAAG,QAAQpB,EAAK,OAChBoB,EAAG,SAASpB,EAAK,QACjBoB,EAAG,YAAYpB,EAAK,WACpBoB,EAAG,cAAcpB,EAAK,aACtBoB,EAAG,WAAWpB,EAAK,UACnBoB,EAAG,qBAAqBpB,EAAK,oBAC7BoB,EAAG,QAAQpB,EAAK,OAChBoB,EAAG,QAAQpB,EAAK,OAChBoB,EAAG,QAAQpB,EAAK;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBE,cAAcA,GAAMoB,GAAI;AACtB,IAAMpB,aAAgB1D,KAAuB8E,aAAc9E,MAE3D8E,EAAG,SAASpB,EAAK,QACjBoB,EAAG,SAASpB,EAAK,QACjBoB,EAAG,UAAUpB,EAAK,SAClBoB,EAAG,OAAO,SAASpB,EAAK,MAAM,GAC9BoB,EAAG,UAAUpB,EAAK,SAClBoB,EAAG,UAAUpB,EAAK,SAClBoB,EAAG,SAAS,SAASpB,EAAK,QAAQ,GAClCoB,EAAG,OAAO,SAASpB,EAAK,MAAM,GAC9BoB,EAAG,WAAWpB,EAAK,UACnBoB,EAAG,OAAO,SAASpB,EAAK,MAAM;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYE,SAASA,GAAMoB,GAAI;AACjB,IAAAA,EAAG,YAAYpB,EAAK,WACpBoB,EAAG,aAAapB,EAAK,YACrBoB,EAAG,YAAY,YAAY,IAAK,GAChCA,EAAG,OAAOpB,EAAK,MACfoB,EAAG,SAASpB,EAAK,QACjBoB,EAAG,OAAOpB,EAAK,MACfoB,EAAG,QAAQpB,EAAK,OAChBoB,EAAG,MAAM,SAASpB,EAAK,KAAK,GAC5BoB,EAAG,KAAK,SAASpB,EAAK,IAAI;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,aAAaqB,GAAI;AACf,WAAK,KAAK,aAAa,aAAaA,CAAE,MACpC,KAAK,aAAa,aAAaA,CAAE,IAAI;AAAA,MACnC,sBAAsB,CAAE;AAAA,MACxB,gBAAgB,CAAE;AAAA,MAClB,YAAY;AAAA,IACb,IAEI,KAAK,aAAa,aAAaA,CAAE;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,cAAcC,GAAa;AACzB,IAAK,KAAK,UAAU,IAAIA,CAAW,KACjC,KAAK,UAAU,IAAIA,GAAa,CAAA,CAAE;AAEpC,UAAM1C,IAAQ,KAAK,UAAU,IAAI0C,CAAW,EAAE,IAAK,KAAI,IAAIA,EAAY,IAAI;AAC3E,WAAA1C,EAAM,aAAaA,EAAM,MACzBA,EAAM,gBAAgB,MACtBA,EAAM,mBAAmB,IACzBA,EAAM,OAAO,MACbA,EAAM,SAAS,MACRA;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYE,UAAUA,GAAO;AACf,QAAIA,EAAM,YAAY;AACpB,YAAM,IAAI,MAAM,mEAAmE;AACrF,UAAM0C,IAAc1C,EAAM;AAC1B,IAAK,KAAK,UAAU,IAAI0C,CAAW,KACjC,KAAK,UAAU,IAAIA,GAAa,CAAA,CAAE,GAEpC,KAAK,UAAU,IAAIA,CAAW,EAAE,KAAK1C,CAAK;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,iBAAiBV,GAAGJ,GAAM;AACxB,UAAMyD,IAAYrD,EAAE,cAAc,QAAQJ,CAAI;AAC9C,QAAKyD;AAEL,UAAI,QAAQA;AACV,QAAIA,EAAU,QACZrD,EAAE,cAAc,eAAeJ,GAAMyD,EAAU,IAAI,QAAQ,EAAI,GACjEA,EAAU,GAAG,KAAKA,EAAU,SAASrD,CAAC;AAAA;AAEtC,iBAASQ,IAAI,GAAGN,IAAImD,EAAU,QAAQ7C,IAAIN,KAAK,CAACF,EAAE,+BAA+BQ;AAC/E,UAAI6C,EAAU7C,CAAC,EAAE,QACfR,EAAE,cAAc,eAAeJ,GAAMyD,EAAU7C,CAAC,EAAE,IAAI,QAAQ,EAAI,GACpE6C,EAAU7C,CAAC,EAAE,GAAG,KAAK6C,EAAU7C,CAAC,EAAE,SAASR,CAAC;AAAA,EAGpD;AACA;","x_google_ignoreList":[0,1,2,3,4,5]}